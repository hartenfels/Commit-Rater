#!/usr/bin/perl
use strict;
use warnings;
use Encode                qw(decode);
use File::Path            qw(make_path);
use File::Spec::Functions qw(catfile);
use File::Slurp           qw(slurp);
use Getopt::Long;
use Git::Repository;
use JSON;
use JSV::Validator;
use Log::Message::Simple;
use Pod::Usage;


my %opts;
GetOptions \%opts, qw(
     remote|r=s
      users|u=s
    verbose|v
       help|h
) or pod2usage(2);

if (@ARGV)
{
    my $args = join ' ', @ARGV;
    warn "Excessive arguments: $args\n";
    pod2usage(2);
}

pod2usage(-exitval => 0, -verbose => 2) if $opts{help};


my $verbose = $opts{verbose};
$Log::Message::Simple::MSG_FH = \*STDERR;


my $json = JSON->new->utf8->canonical->pretty;


my %users;
if (exists $opts{users})
{
    my $mapping = decode_json scalar slurp $opts{users};
    my %schema  = (
        type  => 'array',
        items => {
            type                 => 'object',
            additionalProperties => 0,
            properties           => {
                name     => {type => 'string'},
                email    => {type => 'string'},
                to_email => {type => 'string'},
                to_name  => {type => 'string'},
            },
            allOf                => [
                {anyOf => [
                    {required => [   'name' ]},
                    {required => [   'email']},
                ]},
                {anyOf => [
                    {required => ['to_name' ]},
                    {required => ['to_email']},
                ]},
            ],
        },
    );

    my $result = JSV::Validator->new(environment => 'draft4')
                               ->validate(\%schema, $mapping);
    die "Validation failed:\n", $json->encode($result->errors) if not $result;

    for (@$mapping)
    {
        my $key = ($_->{name} // '') . $; . ($_->{email} // '');
        die "Duplicate rule: $key\n"         if exists $users{$key};
        $users{$key}{name } = $_->{to_name } if exists $_->{to_name };
        $users{$key}{email} = $_->{to_email} if exists $_->{to_email};
    }
}


my $remote  = $opts{remote} or pod2usage(1);
my $dir     = catfile '__repos/', $remote =~ s/\W/_/gr;


my $repo;

sub git
{   ($repo || 'Git::Repository')->run(@_, {fatal => '!0'}) }



if (!-d $dir)
{
    msg "Cloning `$remote` into `$dir`...", $verbose;
    git 'clone', '-q', $remote, $dir;
}

chdir $dir or die "Couldn't cd into work tree $dir: $!\n";

$repo = Git::Repository->new;

msg "Pulling `$remote`...", $verbose;
git 'pull';


msg 'Extracting commits...', $verbose;

sub diff
{
    my ($sha) = @_;

    my %diff;
    for (git 'show', '--format=format:', '--name-status', $sha)
    {
        next unless /\S/;
        my ($op, $file) = split ' ', $_, 2;
        $diff{$file} = $op;
    }

    \%diff
}


my %commits;
for (git 'log', '--format=format:%H%x00%aN%x00%aE%x00%s%x00%P')
{
    my $line = decode 'UTF-8', $_;
    my ($sha, $name, $email, $message, $parents) = split "\0", $line, 5;

    my $map = $users{"$name$;$email"} // $users{"$name$;"} // $users{"$;$email"};
    if (defined $map)
    {
        $name  = $map->{name } if defined $map->{name };
        $email = $map->{email} if defined $map->{email};
    }

    push @{$commits{"$name$;$email"}}, {
        sha     => $sha,
        parents => [split ' ', $parents],
        message => $message,
        diff    => diff($sha),
    };
}


msg 'Formatting output data...', $verbose;

my @out;
for (sort keys %commits)
{
    my ($name, $email) = split $;, $_, 2;
    push @out, {
        name    => $name,
        email   => $email,
        commits => $commits{$_}
    };
}

msg 'Writing JSON...', $verbose;
print $json->encode(\@out);


__END__

=head1 NAME

fetch-commits - Fetch commit info from a git repository.

=head1 SYNOPSIS

    fetch-commits --remote=REPO [OPTIONS]

=head1 DESCRIPTION

This will C<git clone> the given remote repository into the F<__repos> folder
in your current directory, if necessary. Otherwise, it will only C<git pull>
the recent changes.

It will then frobnicate a bit and eventually output a JSON list with each entry
consisting of a list of names and e-mail addresses for the author and a list of
commits that this author made. There may be more than just one name and one
e-mail address per author, because git isn't exactly consistent with them.

=head2 Example Usage

Fetch commits from a GitHub repository:

    fetch-commits --remote=https://github.com/101companies/101worker.git

Fetch commits from a local git repository:

    fetch-commits --remote=~/Commit-Rater

=head1 OPTIONS

=over

=item --remote=REPO, -r REPO

The path to the remote repository from which to extract the commit info.

=item --users=USERS-FILE, -u USERS-FILE

Path to a JSON file that maps names and e-mails in commits to different names
and e-mails. This is used in case people authored commits with inconsistent
author data.

Here's a sample file:

    [
        {
            "name"     : "fred",
            "to_name"  : "Frederick Smith"
        },
        {
            "email"    : "bob@freemailer.net",
            "to_email" : "robert-miller@work.com"
        },
        {
            "name"     : "Mary Walt",
            "email"    : "mary-walt@work.com",
            "to_name"  : "Mary Walt-Smith",
            "to_email" : "mary-walt-smith@work.com"
        }
    ]

This file will map any commits done with the name C<fred> to
C<Frederick Smith>, without changing whatever e-mail is associated with the
commits. The next example is analogous, except with the e-mail address instead
of the name. The final example will map both the name and e-mail address of
the commit, but only if both of them match the given values.

You can combine C<name>, C<email>, C<to_name> and C<to_email> freely, so
something like this is allowed and will change the e-mail address of the commit
if the name of the commit matches C<Frederick Smith>:

    [
        {
            "name"     : "Frederick Smith",
            "to_email" : "fred-smith-23@work.com"
        }
    ]

If multiple rules would match a commit, the precedence is as follows:

=over

=item

C<name> and C<email>

=item

just C<name>

=item

just C<email>

=back

=item --verbose, -v

Spews a bunch of debug information to stderr while running.

=item --help, -h

Show this usage information.

=back

=cut
