#!/usr/bin/perl
use strict;
use warnings;
use Encode                qw(decode);
use File::Path            qw(make_path);
use File::Spec::Functions qw(catfile);
use File::Slurp           qw(slurp);
use Getopt::Long;
use Git::Repository;
use JSON;
use List::Util            qw(first);
use Log::Message::Simple;
use Pod::Usage;


my %opts;
GetOptions \%opts, qw(
     remote|r=s
      users|u=s
    verbose|v
       help|h
) or pod2usage(2);

if (@ARGV)
{
    my $args = join ' ', @ARGV;
    warn "Excessive arguments: $args\n";
    pod2usage(2);
}

pod2usage(-exitval => 0, -verbose => 2) if $opts{help};


my $verbose = $opts{verbose};
$Log::Message::Simple::MSG_FH = \*STDERR;


my %users;
if (exists $opts{users})
{
    for (@{decode_json scalar slurp $opts{users}})
    {
        my $key = ($_->{name} // '') . $; . ($_->{email} // '');
        $users{$key}{name } = $_->{to_name } if exists $_->{to_name };
        $users{$key}{email} = $_->{to_email} if exists $_->{to_email};
    }
}


my $remote  = $opts{remote} or pod2usage(1);
my $dir     = catfile '__repos/', $remote =~ s/\W/_/gr;


my $repo;

sub git
{   ($repo || 'Git::Repository')->run(@_, {fatal => '!0'}) }



if (!-d $dir)
{
    msg "Cloning `$remote` into `$dir`...", $verbose;
    git 'clone', '-q', $remote, $dir;
}

chdir $dir or die "Couldn't cd into work tree $dir: $!\n";

$repo = Git::Repository->new;

msg "Pulling `$remote`...", $verbose;
git 'pull';


my %commits;

for (git 'log', '--format=format:%H%x00%aN%x00%aE%x00%s%x00%P')
{
    my $line = decode 'UTF-8', $_;
    my ($sha, $name, $email, $message, $parents) = split "\0", $line, 5;

    my $key = "$name$;$email";
    my $map = $users{$key} // $users{"$name$;"} // $users{"$;$email"};
    if (defined $map)
    {
        $name  = $map->{name } if defined $map->{name };
        $email = $map->{email} if defined $map->{email};
    }

    push @{$commits{$key}}, {
        sha     => $sha,
        parents => [split ' ', $parents],
        message => $message,
    };
}


my @out;

for (sort keys %commits)
{
    my ($name, $email) = split $;, $_, 2;
    push @out, {
        name    => $name,
        email   => $email,
        commits => $commits{$_}
    };
}

print JSON->new->utf8->canonical->pretty->encode(\@out);


__END__

=head1 NAME

fetch-commits - Fetch commit info from a git repository.

=head1 SYNOPSIS

    fetch-commits --remote=REPO [OPTIONS]

=head1 DESCRIPTION

This will C<git clone> the given remote repository into the F<__repos> folder
in your current directory, if necessary. Otherwise, it will only C<git pull>
the recent changes.

It will then frobnicate a bit and eventually output a JSON list with each entry
consisting of a list of names and e-mail addresses for the author and a list of
commits that this author made. There may be more than just one name and one
e-mail address per author, because git isn't exactly consistent with them.

=head2 Example Usage

Fetch commits from a GitHub repository:

    fetch-commits --remote=https://github.com/101companies/101worker.git

Fetch commits from a local git repository:

    fetch-commits --remote=~/Commit-Rater

=head1 OPTIONS

=over

=item --remote=REPO, -r REPO

The path to the remote repository from which to extract the commit info.

=item --verbose, -v

Spews a bunch of debug information to stderr while running.

=item --help, -h

Show this usage information.

=back

=cut
